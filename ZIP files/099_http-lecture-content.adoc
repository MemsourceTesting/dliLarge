ifndef::backend-docbook5,backend-docbook45[:imagesdir: ../../..]
[id='resthttp-lecture']
= Consuming HTTP services with the HTTP4 component

== Consuming HTTP Services

Camel provides the `+http4+` component to integrate with technologies over HTTP.
This component can consume contents from an HTTP server, or even use GET and POST HTTP methods with a REST service to retrieve or create data.
The `+http4+` component provides an easy way to consume HTTP services, but cannot produce a REST service.
//ZG: How is this different than the REST dsl? When would you use one over the other?
//RT: Sentence added above.
The `+http4+` component is provided by the `+camel-http4+` library and uses the following endpoint URI format:

[subs=+quotes]
----
http[s]4://hostname[:port][/resourceURI][?options]
----

By default, the `+http4+` component uses port 80 for HTTP or port 443 for HTTPS.

To import the `+camel-http4+` library, include the following configuration in the `+pom.xml+` file:

[subs=+quotes]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-http4</artifactId>
</dependency>
----

Alternatively, use the `+camel-http4-starter+` library to enable autoconfiguration with Spring Boot.

Camel always uses the `+InOut+` message exchange protocol because of the HTTP protocol nature (based on a request/response paradigm).

[NOTE]
====
You can only produce to endpoints generated by the `+http4+` component. Therefore, it should never be used as input into your Camel routes.
====

Camel uses the following algorithm to determine if either the `+GET+` or `+POST+` HTTP method should be used:

. The method provided in the header field called `+Exchange.HTTP_METHOD+`.
. GET, if a query string is provided in the header `+Exchange.HTTP_QUERY+`.
. GET, if the endpoint is configured with a query string.
. POST, if there is data to send (body is not null).
. GET, otherwise.

Therefore, by default, depending on the content contained in the body of the `+inMessage+` object on the exchange, Camel either sends a GET or POST request as follows:

* Sends an HTTP POST request to the URL by using the exchange body as the body of the HTTP request and returns the HTTP response as the `+outMessage+` object on the exchange, if there is message content.
* If the body is null then it sends an HTTP GET request to the URL and returns the response as the `+outMessage+` object on the exchange.

Endpoint options and HTTP query parameters have the same syntax.
You must use the `+Exchange.HTTP_QUERY+` header to set HTTP query parameters.
For example, to make the `+http://example.com?order=123&detail=short+` GET request, use the following:

[subs=+quotes]
----
from("direct:start")
  .setHeader(`+Exchange.HTTP_QUERY+`, constant("*order=123&detail=short*"))
  .to("http4://example.com");
----

You can also use the `+connectTimeout+` endpoint option in the `+http4+` endpoint, as the following example shows:

[subs=+quotes]
----
from("direct:start")
  .setHeader(Exchange.HTTP_QUERY, constant("order=123&detail=short"))
  .to("http4://example.com?*connectTimeout=2000*");
----

=== Handling HTTP Errors

When you use the `+camel-http4+` component, Camel can throw an exception depending on the HTTP response code returned by the external resource:

A response code from 100 to 299 is a success.

If the response code is 300 or greater, then Camel throws an `+HttpOperationFailedException+` exception with any error messages attached to the response.

The option `+throwExceptionOnFailure+` can be set to false to prevent the `+HttpOperationFailedException+` exception from being thrown for failed response codes.
This option allows you to get any response code from the remote server without Camel throwing an exception.
The following example route demonstrates this:

[subs=+quotes]
----
from("direct:start")
.setHeader(Exchange.HTTP_QUERY, constant("order=123&detail=short"))
.to("http4://example.com?*throwExceptionOnFailure=false*");
----

== Enriching Message Exchanges

When sending data from one system to another, it is common for the receiving system to require more information than the source can provide.
For example, the source system's data might only contain a customer ID, but the receiving system actually requires the customer name and address.
Similarly, an order message sent by the order management system might only contain an order number.
However, you must find the items associated with that order, so that you can pass it to the order fulfillment system.

In these situations, use the content enricher pattern in your Camel route to enrich or enhance your message exchange with the required additional data.
The `+http4+` component is a common option for acquiring the additional data.

Camel supports the enrich EIP by using the `+enrich+` DSL method to enrich the message.
The enrich DSL method has two parameters.
The first is the URI of the producer Camel must invoke to retrieve the enrichment data.
The second parameter is an optional instance of the `+AggregationStrategy+` implementation, which you must provide to Camel for use when combining the original message exchange with the enrichment data.
If you do not provide an aggregation strategy, then Camel uses the body obtained from the resource as the enriched message exchange.

The enrich method synchronously retrieves additional data from a resource endpoint to enrich an incoming message (contained in the original exchange).
Here is an example template for implementing an aggregation strategy to use with the enrich DSL method:

[subs=+quotes]
----
public class ExampleAggregationStrategy implements AggregationStrategy {

    public Exchange aggregate(Exchange original, Exchange resource) {
        Object originalBody = original.getIn().getBody();
        Object resource = resource.getIn().getBody();
        Object mergeResult =...// combine original body and resource response
        if (original.getPattern().isOutCapable()) {
            original.getOut().setBody(mergeResult);
        } else {
            original.getIn().setBody(mergeResult);
        }
        return original;
    }
}
----

You can use the `+http4+` component in conjunction with the content enricher pattern to update your message exchanges with data from an external web resource.
You could use this to retrieve some relevant data from an external system exposed over HTTP.
This approach is especially helpful in a microservices-based environment.
The following example implements this use case:

[subs=+quotes]
----
from("activemq:orders")
 .enrich("direct:enrich", <1>
    new HttpAggregationStrategy()) <2>
 .log("Order sent to fulfillment: ${body}")
 .to("mock:fulfillmentSystem");

from("direct:enrich") <3>
 .setBody(constant(null)) <4>
 .to("http4://webservice.example.com"); <5>
----
<1> The URI for the producer that the enrich DSL element invokes to retrieve the resource message.
<2> The `+AggregationStrategy+` implementation that the enrich DSL element uses to combine the original message exchange and the resource message.
<3> The URI for the consumer that the enrich DSL element invokes.
<4> Setting the body of the exchange to null causes the `+http4+` component to send an HTTP GET request to the resource.
<5> The URI for the HTTP component producer is the address of the external web service.

In the Camel route from the previous example, the implementation of `+HttpAggregationStrategy+` that Camel uses to create the enriched message is shown in the following example:

[subs=+quotes]
----
public class HttpAggregationStrategy implements AggregationStrategy{

@Override
public Exchange aggregate(Exchange original, Exchange resource) {
    Order originalBody = original.getIn().getBody(Order.class); <1>
    String resourceResponse = resource.getIn().getBody(String.class); <2>
    originalBody.setFulfilledBy(resourceResponse); <3>
    return original;
  }
}
----
<1> Retrieve the original message exchange body as an instance of the Order model class.
<2> Retrieve the resource message exchange body as a Java String.
<3> Set the response as the fufilledBy property on the Order object.

== Consuming SOAP Services

The Simple Object Access Protocol (SOAP) is an application communication protocol for sending and receiving messages using XML in a way that is  platform independent.
SOAP provides a way to communicate between applications running on different operating systems, with different technologies and programming languages.

While the `+http4+` component could be used to query a SOAP application, additional tools are required to build SOAP requests.
The additional tools are provided by the `+camel-cxf+` library.
The `+camel-cxf+` library provides a `+cxf+` component that is a wrapper for Apache CXF, a Java library for working with web services.
To invoke a SOAP service in a camel route, take the following three steps:

. Create client classes from the WSDL
. Create the request payload
. Set up the CXF (SOAP) endpoint in the route

=== Creating Client Classes from the WSDL

The Web Service Description Language (WSDL) is an XML based definition language.
The WSDL file describes the functionality of a SOAP-based web service.

Use the `+cxf-codgen-plugin+` for Maven to create the Java classes from your WSDL file.
To use this feature, first include the following in your project's `+pom.xml+`:

[subs=+quotes]
----
<plugin>
   <groupId>org.apache.cxf</groupId>
   <artifactId>cxf-codegen-plugin</artifactId> <1>
   <version>${cxf.version}</version>
   <executions>
     <execution>
       <id>generate-sources</id>
       <phase>generate-sources</phase>
       <configuration>
         <wsdlOptions>
           <wsdlOption>
             <wsdl>src/main/resources/wsdl/Footprint.wsdl</wsdl> <2>
           </wsdlOption>
         </wsdlOptions>
       </configuration>
       <goals>
         <goal>wsdl2java</goal>
       </goals>
     </execution>
   </executions>
 </plugin>
----
<1> The `+cxf-codgen-plugin+` creates and compiles Java classes from the WSDL file to the `+target/generated-sources/cxf+` directory.
<2> Obtain the WSDL file from the web service and copy it to the `+src/main/resources/wsdl+` directory.

To generate classes from the WSDL use the following Maven command:

[subs=+quotes]
----
mvn generate-sources
----

=== Creating the Request Payload

Now that you have the WSDL classes generated, use a Java bean to create a Java object of the classes that represent the service's request type.
For the `+Footprint+` service, the request type might be `+GetFootprintRequest+`.
An example class follows:

[subs=+quotes]
----
public class GetFootprintBuilder {

     public GetFootprintRequest getFootprint(String id) {
         GetFootprintRequest request = new GetFootprintRequest();
         request.setID(id);

         return request;
     }
 }
----

This class can now be used in the route.

=== Setting up the CXF (SOAP) Endpoint in the Route

In the route, invoke the Java bean from the previous step.
The following example invokes the `+GetFootprintBuilder+` bean.

[subs=+quotes]
----
from("direct:start")
     .setBody(constant("12"))  <1>
     .bean(GetFootprintBuilder.class) <2>
_..._
----
<1> The value of `+12+` in the message body is set to use in the `+id+` parameter.
<2> When the GetFootprintBuilder bean is invoked, camel uses `+bean parameter binding+` to pass the value 12 as the argument to the `+getFootprint(String id)+` method.
The bean replaces the exchange body with a `+GetFootPrintRequest+` object with an `+id+` value of `+12+`.

Identify the generated `+serviceClass+` for the SOAP operation.
The class is an `+interface+` that includes the values that must match the `+cxf+` component configuration.
Use the `+OPERATION_NAME+` and `+OPERATION_NAMESPACE+` in the message header, as illustrated in the following example:

[subs=+quotes]
----
from("direct:start")
     .setBody(constant("12"))
     .bean(GetFootprintBuilder.class)
     `+.setHeader(CxfConstants.OPERATION_NAME, constant("GetFootprint"))+`
     `.setHeader(CxfConstants.OPERATION_NAMESPACE,
      constant("http://training.redhat.com/FootprintService/"))`

_..._
----

Finally, the `+cxf+` endpoint requires the following parameters.

[subs=+quotes]
----
from("direct:start")
     .setBody(constant("12"))
     .bean(GetFootprintBuilder.class)
     .setHeader(CxfConstants.OPERATION_NAME, constant("GetFootprint"))
     .setHeader(CxfConstants.OPERATION_NAMESPACE,
      constant("http://training.redhat.com/FootprintService/"))
     `+.to("cxf://http://localhost:8423/ws"+` <1>
     `++ "?serviceClass=com.redhattraining.service.FootprintServiceEndpoint")+` <2>
----
<1>  URL for the service
<2> Interface generated by the `+cxf-codegen-plugin+` plug-in that represents the SOAP service endpoint.


== {nbsp}

[role="References"]
[NOTE]
====
https://tomd.xyz/camel-consume-soap-service/[Consuming a SOAP service with Apache Camel]

// Template for a reference that does link to Red Hat Documentation.
For more information, refer to the _Http4 Component_ chapter in the _Apache Camel Component Reference_ at https://access.redhat.com/documentation/en-us/red_hat_fuse/7.10/html-single/apache_camel_component_reference/index#http4-component

For more information, refer to the _CXF Component_ chapter in the _Apache Camel Component Reference_ at  https://access.redhat.com/documentation/en-us/red_hat_fuse/7.10/html-single/apache_camel_component_reference/index#cxf-component
====
